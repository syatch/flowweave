**Note:** The MD files under `docs/` were generated by AI and partially edited by developers.ã€€They may contain some inaccuracies.

# FlowWeave Task / Operator Guide

This document explains how to implement tasks (operators) for FlowWeave.

## 1. Task Class Structure

Each operator must define a `Task` class that inherits from `FlowWeaveTask` and a runner class that inherits from `FlowWeaveTaskRunner`.

Example:

```python
from flowweave import FlowWeaveTask, FlowWeaveTaskRunner, Result

class Test(FlowWeaveTaskRunner):
    def __init__(self):
        self.source_dir = ""
        self.export_dir = ""

    def __call__(self):
        self.message("called 1")
        return Result.SUCCESS

class Task(FlowWeaveTask):
    runner = Test
```

### Key Points:
- `FlowWeaveTaskRunner` contains the actual execution logic in `__call__()`.
- `FlowWeaveTask` wraps the runner and manages integration with FlowWeave.
- Options are automatically injected from FlowWeave configuration.

## 2. Options Handling

Options can come from `default_option`, `global_option`, or task-specific YAML.
They are injected into the runner as attributes.

Example:

```python
for key, value in task_data.option.items():
    if hasattr(task_instance, key):
        setattr(task_instance, key, value)
```

## 3. Messaging and Logging

Use `FlowMessage` to log task start, end, and ignore events.

- Logging is controlled by `task_data.show_log`.
- Tasks can call `self.message(msg)` to add custom logs.

## 4. Error Handling

- Exceptions in `__call__` are caught by FlowWeave and reported via `FlowMessage.error`.
- Task result is automatically marked as `Result.FAIL` on exception.

## 5. Summary

- Define a runner class inheriting `FlowWeaveTaskRunner`.
- Define a `Task` class inheriting `FlowWeaveTask` pointing to the runner.
- Use options and logging as provided.
- FlowWeave handles execution, chaining, and result aggregation automatically.
